plugins {
	id 'java'
	id 'org.ajoberstar.grgit' version '4.1.1'
}
import org.ajoberstar.grgit.Grgit

tasks.withType(JavaCompile).configureEach {
	options.with {
		encoding = 'UTF-8'
		release.set(17) // don't forget to update README.md
	}
}

repositories {
	mavenCentral()
}

dependencies {
	// don't forget to update "third-party-software.html"
	implementation 'dev.dirs:directories:26' // https://github.com/dirs-dev/directories-jvm
	implementation 'com.google.code.gson:gson:2.10'

	testImplementation 'org.junit.jupiter:junit-jupiter:5.9.1'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.1'
}

tasks.named('test', Test) {
	useJUnitPlatform()

	testLogging { // add stdout logging for running `./gradlew test`
		lifecycle {
			events "passed", "skipped", "failed"
			exceptionFormat 'full'
		}
	}

	afterSuite { description, result ->
		if (!description.parent) { // will match the outermost suite
			def stats = "${result.testCount} tests run, ${result.successfulTestCount} successes, " +
				"${result.failedTestCount} failures, ${result.skippedTestCount} ignored"
			println('-' * stats.length())
			println("Testing result for ${project.name}: ${result.resultType}")
			println(stats)
			println('-' * stats.length())
		}
	}

	reports {
		junitXml.required = true
		html.required = true // see ./build/reports/tests/test/index.html
	}
}

/**
 * Generate a version string with a lot of information.
 * TODO maybe generate Version.java from Gradle?
 */
String calculateVersion() {
	final String defaultVersion = '1.5-nongit'
	final Grgit git = Grgit.open(dir: project.rootDir)
	try {
		/*
	 * If possible, use an annotated tag which starts with letter 'v' and some numbers.
	 */
		final String description = git.describe(match: ["v[0-9]*"], commit: "HEAD")
		if (description != null && description.matches("^v[0-9]+[^ ]*")) {
			def updateIndex = 'git update-index -q --refresh'.execute()
			updateIndex.waitForOrKill(10000)
			Process diffIndex = 'git diff-index --name-only HEAD -- .'.execute()
			String output = diffIndex.text
			if (output.length() != 0) {
				return description + '-dirty'
			}
			return description
		}
	} catch (e) {
		logger.warn("Could not use Git.", e)
	}
	return defaultVersion
}

/**
 * Calculate who has built the artifacts.
 */
static String calculateResodayBuilderName() {
	try {
		final Process gitUserName = 'git config user.name'.execute()
		return gitUserName.text.trim() // git config outputs a newline, which must be trimmed
	} catch (ignored) {
		return System.getProperty("user.name")
	}
}

project.version = calculateVersion()

tasks.named('processResources', Copy) {
	filesMatching('**/about.html') {
		filter {
			it.replace('@VERSION@', project.version)
		}
	}
}

def resodayJarAttributes = [
	'Implementation-Title'  : 'Resoday built by ' + calculateResodayBuilderName(),
	'Implementation-Version': project.version,
	'Main-Class'            : 'dev.andrybak.resoday.Resoday'
]

tasks.named('jar', Jar) {
	manifest {
		attributes(resodayJarAttributes)
	}
}

tasks.register('releaseJar', Jar) {
	group = 'release'
	description = 'Create a release jar of Resoday'

	archiveBaseName.set('resoday')
	archiveAppendix.set('release')

	destinationDirectory.set(file('build/distributions/'))

	manifest {
		attributes(resodayJarAttributes)
	}

	dependsOn(jar)
	from(zipTree(jar.getArchiveFile()))
	from {
		configurations.runtimeClasspath.collect {
			it.isDirectory() ? it : zipTree(it)
		}
	}
}

tasks.register('release') {
	group = 'release'
	description = 'Run all tests and create a release jar'
	dependsOn('build', 'releaseJar')
}

tasks.named('wrapper') {
    distributionType = Wrapper.DistributionType.ALL
}
