plugins {
	id("java")
	alias(libs.plugins.grgit)
}
import org.ajoberstar.grgit.Grgit
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import java.util.concurrent.TimeUnit

tasks.withType(JavaCompile).configureEach {
	options.with {
		encoding = "UTF-8"
		release.set(17) // don't forget to update README.md
	}
}

repositories {
	mavenCentral()
}

dependencies {
	// when adding new dependencies, please update task processResources
	implementation(libs.directories) // https://github.com/dirs-dev/directories-jvm
	implementation(libs.gson)

	testImplementation(platform(libs.junitBom))
	testImplementation(libs.junitJupiter)
	testRuntimeOnly(libs.junitPlatformLauncher)
}

tasks.named("test", Test) {
	useJUnitPlatform()

	testLogging { // add stdout logging for running `./gradlew test`
		lifecycle {
			events("passed", "skipped", "failed")
			exceptionFormat = TestExceptionFormat.FULL
		}
	}

	afterSuite { description, result ->
		if (!description.parent) { // will match the outermost suite
			final String stats = "${result.testCount} tests run, ${result.successfulTestCount} successes, " +
				"${result.failedTestCount} failures, ${result.skippedTestCount} ignored"
			println("-" * stats.length())
			println("Testing result for ${project.name}: ${result.resultType}")
			println(stats)
			println("-" * stats.length())
		}
	}

	reports {
		junitXml.required.set(true)
		html.required.set(true) // see ./build/reports/tests/test/index.html
	}
}

static void waitForOrKill(Process self, long millis) {
	if (!self.waitFor(millis, TimeUnit.MILLISECONDS)) {
		self.destroy()
	}
}

/**
 * Generate a version string with a lot of information.
 * Logic is based on a Shell script used for generating version string of Git:
 * https://git.kernel.org/pub/scm/git/git.git/tree/GIT-VERSION-GEN
 * TODO maybe generate Version.java from Gradle?
 */
String calculateVersion() {
	final String defaultVersion = "1.6-nongit"
	final Grgit git = Grgit.open(dir: project.rootDir)
	try {
		/*
		 * If possible, use an annotated tag which starts with letter 'v' and some numbers.
		 */
		final String description = git.describe(match: ["v[0-9]*"], commit: "HEAD")
		if (description != null && description.matches("^v[0-9]+[^ ]*")) {
			final Process updateIndex = new ProcessBuilder("git", "update-index", "-q", "--refresh").start()
			waitForOrKill(updateIndex, 10000)
			final Process diffIndex = new ProcessBuilder("git", "diff-index", "--name-only", "HEAD", "--", ".").start()
			waitForOrKill(diffIndex, 10000)
			final String output = diffIndex.text
			if (output.length() != 0) {
				return description + "-dirty"
			}
			return description
		}
	} catch (e) {
		logger.warn("Could not use Git.", e)
	}
	return defaultVersion
}

/**
 * Calculate who has built the artifacts.
 */
static String calculateResodayBuilderName() {
	try {
		final Process gitUserName = new ProcessBuilder("git", "config", "user.name").start()
		waitForOrKill(gitUserName, 10000)
		return gitUserName.text.trim() // git config outputs a newline, which must be trimmed
	} catch (ignored) {
		return System.getProperty("user.name")
	}
}

project.version = calculateVersion()

tasks.named("processResources", Copy) {
	filesMatching("**/about.html") {
		expand(["version": project.version])
	}
	filesMatching("**/third-party-software.html") {
		expand([
			"directoriesVersion": libs.directories.get().version,
			"gsonVersion": libs.gson.get().version,
			"gradleVersion": rootProject.gradle.gradleVersion,
			"junitVersion": libs.junitBom.get().version,
			"grgitVersion": libs.plugins.grgit.get().version,
		])
	}
}

def resodayJarAttributes = [
	"Implementation-Title"  : "Resoday built by " + calculateResodayBuilderName(),
	"Implementation-Version": project.version,
	"Main-Class"            : "dev.andrybak.resoday.Resoday"
]

final TaskProvider<Jar> jarTask = tasks.named("jar", Jar) {
	manifest {
		attributes(resodayJarAttributes)
	}
}

tasks.register("releaseJar", Jar) {
	group = "release"
	description = "Create a release jar of Resoday"

	archiveBaseName.set("resoday")
	archiveAppendix.set("release")

	destinationDirectory.set(file("build/distributions/"))

	manifest {
		attributes(resodayJarAttributes)
	}

	with(jarTask.get() as CopySpec)
	from(configurations.runtimeClasspath.collect {
		it.isDirectory() ? it : zipTree(it)
	})
}

tasks.register("release") {
	group = "release"
	description = "Run all tests and create a release jar"
	dependsOn("build", "releaseJar")
}

tasks.named("wrapper") {
    distributionType = Wrapper.DistributionType.ALL
}
