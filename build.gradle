plugins {
	id("java")
	id("org.ajoberstar.grgit") version "5.2.0"
}
import org.ajoberstar.grgit.Grgit
import org.gradle.api.tasks.testing.logging.TestExceptionFormat

tasks.withType(JavaCompile).configureEach {
	options.with {
		encoding = "UTF-8"
		release.set(17) // don't forget to update README.md
	}
}

repositories {
	mavenCentral()
}

dependencies {
	// don't forget to update "third-party-software.html"
	implementation("dev.dirs:directories:26") // https://github.com/dirs-dev/directories-jvm
	implementation("com.google.code.gson:gson:2.10")

	testImplementation(platform("org.junit:junit-bom:5.10.0"))
	testImplementation("org.junit.jupiter:junit-jupiter")
	testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

tasks.named("test", Test) {
	useJUnitPlatform()

	testLogging { // add stdout logging for running `./gradlew test`
		lifecycle {
			events("passed", "skipped", "failed")
			exceptionFormat = TestExceptionFormat.FULL
		}
	}

	afterSuite { description, result ->
		if (!description.parent) { // will match the outermost suite
			final String stats = "${result.testCount} tests run, ${result.successfulTestCount} successes, " +
				"${result.failedTestCount} failures, ${result.skippedTestCount} ignored"
			println("-" * stats.length())
			println("Testing result for ${project.name}: ${result.resultType}")
			println(stats)
			println("-" * stats.length())
		}
	}

	reports {
		junitXml.required.set(true)
		html.required.set(true) // see ./build/reports/tests/test/index.html
	}
}

/**
 * Generate a version string with a lot of information.
 * Logic is based on a Shell script used for generating version string of Git:
 * https://git.kernel.org/pub/scm/git/git.git/tree/GIT-VERSION-GEN
 * TODO maybe generate Version.java from Gradle?
 */
String calculateVersion() {
	final String defaultVersion = "1.6-nongit"
	final Grgit git = Grgit.open(dir: project.rootDir)
	try {
		/*
		 * If possible, use an annotated tag which starts with letter 'v' and some numbers.
		 */
		final String description = git.describe(match: ["v[0-9]*"], commit: "HEAD")
		if (description != null && description.matches("^v[0-9]+[^ ]*")) {
			final Process updateIndex = "git update-index -q --refresh".execute()
			updateIndex.waitForOrKill(10000)
			final Process diffIndex = "git diff-index --name-only HEAD -- .".execute()
			final String output = diffIndex.text
			if (output.length() != 0) {
				return description + "-dirty"
			}
			return description
		}
	} catch (e) {
		logger.warn("Could not use Git.", e)
	}
	return defaultVersion
}

/**
 * Calculate who has built the artifacts.
 */
static String calculateResodayBuilderName() {
	try {
		final Process gitUserName = "git config user.name".execute()
		return gitUserName.text.trim() // git config outputs a newline, which must be trimmed
	} catch (ignored) {
		return System.getProperty("user.name")
	}
}

project.version = calculateVersion()

tasks.named("processResources", Copy) {
	filesMatching("**/about.html") {
		expand(["version": project.version])
	}
}

def resodayJarAttributes = [
	"Implementation-Title"  : "Resoday built by " + calculateResodayBuilderName(),
	"Implementation-Version": project.version,
	"Main-Class"            : "dev.andrybak.resoday.Resoday"
]

final TaskProvider<Jar> jarTask = tasks.named("jar", Jar) {
	manifest {
		attributes(resodayJarAttributes)
	}
}

tasks.register("releaseJar", Jar) {
	group = "release"
	description = "Create a release jar of Resoday"

	archiveBaseName.set("resoday")
	archiveAppendix.set("release")

	destinationDirectory.set(file("build/distributions/"))

	manifest {
		attributes(resodayJarAttributes)
	}

	with(jarTask.get() as CopySpec)
	from(configurations.runtimeClasspath.collect {
		it.isDirectory() ? it : zipTree(it)
	})
}

tasks.register("release") {
	group = "release"
	description = "Run all tests and create a release jar"
	dependsOn("build", "releaseJar")
}

tasks.named("wrapper") {
    distributionType = Wrapper.DistributionType.ALL
}
